# Area 3: Messaging Platform Framework

The current Telegram integration is tightly coupled: a single bot token stored in `.env`, a single whitelist, one agent config shared by all users, and all configuration via environment variables. The `TelegramBot` class in `telegram_interface.py` is ~280 lines and self-contained.

---

### Task 3.1 -- YAML-Based Bot Configuration

**Difficulty**: Medium | **Dependencies**: None (foundational for all messaging tasks)

Replace environment variable-based Telegram config with a structured YAML file (`.flavia/bots.yaml`). Example schema:

```yaml
bots:
  research-bot:
    platform: telegram
    token: "${TELEGRAM_BOT_TOKEN_RESEARCH}"
    default_agent: main
    access:
      allowed_users: [123456789]
      allow_all: false

  study-bot:
    platform: telegram
    token: "${TELEGRAM_BOT_TOKEN_STUDY}"
    default_agent: summarizer
    access:
      allowed_users: [123456789, 987654321]
      allow_all: false

  whatsapp-assistant:
    platform: whatsapp
    credentials:
      phone_number_id: "${WA_PHONE_ID}"
      access_token: "${WA_ACCESS_TOKEN}"
    default_agent: main
    access:
      allowed_users: ["+5511999999999"]

  web-api:
    platform: web
    port: 8080
    default_agent: main
    access:
      api_key: "${WEB_API_KEY}"
```

Maintain backward compatibility: if `bots.yaml` does not exist, fall back to current env var behavior (`TELEGRAM_BOT_TOKEN`, `TELEGRAM_ALLOWED_USER_IDS`, `TELEGRAM_ALLOW_ALL_USERS`).

Environment variable expansion (`${VAR}`) should use the same mechanism as `providers.yaml`.

**Key files to modify/create**:
- `config/settings.py` -- load bot configs alongside other settings
- `config/loader.py` -- discover `bots.yaml` in config paths
- `.flavia/bots.yaml` -- new config file (generated by setup wizard)
- `setup/telegram_wizard.py` -- update to generate `bots.yaml` entries

---

### Task 3.2 -- Per-Conversation Agent Binding

**Difficulty**: Medium | **Dependencies**: Task 3.1

Allow each bot instance (and each conversation/user within a bot) to be bound to a specific agent from `agents.yaml`. Each bot in `bots.yaml` specifies a `default_agent`. Users can switch agents within their conversation.

New Telegram commands:
- `/agent <name>` -- switch to a different agent (resets conversation history)
- `/agents` -- list available agents from `agents.yaml`

Implementation: The `_get_or_create_agent()` method looks up the bot's configured `default_agent` instead of always using `"main"`. A per-user agent override dict tracks manual switches.

**Key files to modify**:
- `interfaces/telegram_interface.py` -- agent lookup from bot config, new commands

---

### Task 3.3 -- Multi-Bot Support ✅

**Difficulty**: Medium | **Dependencies**: Task 3.1, Task 3.2 | **Status**: Done

Allow multiple bot instances to run simultaneously from the same `.flavia/` directory. Each entry in `bots.yaml` maps to a separate bot instance.

The `--telegram` flag starts all configured Telegram bots by default, or `--telegram <bot-name>` for a specific one. Uses `asyncio.gather()` to run multiple bots concurrently in the same process.

**Key files modified/created**:
- `interfaces/bot_runner.py` (new) -- async bot runner utilities with `_run_multiple_bots_async()` and `run_telegram_bots()`
- `cli.py` -- updated `--telegram` argument to accept optional `bot_name` parameter
- `interfaces/__init__.py` -- export `run_telegram_bots()` for backward compatibility

**See documentation**: [Task 3.3 Details](../completed/task-3.3-multi-bot-support.md)

---

### Task 3.4 -- Abstract Messaging Interface ✅

**Difficulty**: Hard | **Dependencies**: Task 3.1, Task 3.2 | **Status**: Done

Extract a `BaseMessagingBot` abstract class from `TelegramBot` that defines the common interface for all messaging platforms. This becomes the foundation for WhatsApp, Web API, and any future platform.

```
interfaces/
├── base_bot.py          # BaseMessagingBot ABC
├── cli_interface.py     # (unchanged)
├── telegram_bot.py      # TelegramBot(BaseMessagingBot)
├── whatsapp_bot.py      # WhatsAppBot(BaseMessagingBot)
└── web_api.py           # WebAPIBot(BaseMessagingBot)
```

The ABC should handle:
- Authentication and authorization (configurable per platform)
- Agent lifecycle management (get/create/reset per user)
- Message chunking for platform-specific size limits
- Command routing (platform-agnostic command registry)
- Structured logging

Platform-specific subclasses handle only API communication (receiving messages, sending responses, platform-specific formatting).

**Key files to modify/create**:
- `interfaces/base_bot.py` (new ABC)
- `interfaces/telegram_interface.py` -- refactor to extend `BaseMessagingBot`

**See documentation**: [Task 3.4 Details](../completed/task-3.4-abstract-messaging-interface.md)

---

### Task 3.5 -- WhatsApp Integration

**Difficulty**: Hard | **Dependencies**: Task 3.4

Implement `WhatsAppBot(BaseMessagingBot)`. Two approaches to evaluate at implementation time:

**Option A -- Official WhatsApp Business API (Meta Cloud API)**:
- Uses webhooks: requires running a web server (e.g., `aiohttp`, `FastAPI`) to receive incoming messages
- Reliable and officially supported
- Requires Meta business verification and a phone number
- Message templates needed for initiating conversations
- Supports text, images, documents, audio

**Option B -- Third-party libraries**:
- Libraries like `whatsapp-web.js` (Node.js, would require a bridge) or pure-Python alternatives
- Easier to set up, no business verification
- Less stable, against WhatsApp ToS, may break with updates

The abstract interface from Task 3.4 ensures the choice does not affect the rest of the system. Both approaches should be evaluated; the decision is deferred to implementation time.

**Key files to create**:
- `interfaces/whatsapp_bot.py` (new)
- Webhook server infrastructure (if using official API)

**New dependencies**: `aiohttp` or `fastapi` + `uvicorn` (for webhook server), or platform-specific client library.

---

### Task 3.6 -- Web API Interface

**Difficulty**: Medium | **Dependencies**: Task 3.4

Create a simple HTTP/WebSocket API server (`WebAPIBot`) that exposes the agent as a programmable endpoint. Use `aiohttp` or `FastAPI`.

Proposed endpoints:
- `POST /chat` -- send a message, receive the agent response
- `POST /reset` -- reset conversation for a session
- `GET /agents` -- list available agents
- `POST /agent` -- switch active agent for a session
- `WebSocket /ws` -- streaming conversation (optional, for real-time UX)

Authentication via API key (configured in `bots.yaml`). Session management via tokens or session IDs.

This enables custom web frontends, mobile apps, or integration with other services and automation pipelines.

**Key files to create**:
- `interfaces/web_api.py` (new)

**New dependencies**: `aiohttp` or `fastapi` + `uvicorn` (optional extras).

---

**[← Back to Roadmap](../../roadmap.md)**
